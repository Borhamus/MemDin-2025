# Descripción del Simulador de Memoria Dinámica

El simulador tiene como objetivo representar el funcionamiento de un **sistema multiprogramado y monoprocesador** con **asignación dinámica de memoria mediante particiones contiguas**, permitiendo comparar distintas estrategias de asignación y medir indicadores de desempeño.

---

## 1. Entrada del Usuario

El simulador solicita al usuario los siguientes datos:

* **Tanda de procesos** (desde archivo JSON o ingreso manual).
  Cada proceso contiene:

  * `id`: Identificador del proceso (ej. `P1`, `P2`)
  * `arrivaltime`: Instante de arribo
  * `duracion`: Tiempo de permanencia en memoria
  * `memReq`: Tamaño de memoria requerida (KB)

* **Tamaño de memoria física** disponible (en KB).

* **Estrategia de asignación** de particiones: *First Fit, Best Fit, Next Fit, Worst Fit*.

* **Tiempo de selección de partición** (overhead de búsqueda y creación).

* **Tiempo de carga promedio** (transferencia desde memoria secundaria).

* **Tiempo de liberación** (overhead de unificación/liberación de particiones).

---

## 2. Inicio de Simulación

Al presionar **"Ejecutar Simulación"**, el sistema realiza:

1. **Inicialización de memoria** con el tamaño definido.
2. **Carga de procesos** en una lista interna.
3. **Ordenamiento** de la lista por `arrivaltime` ascendente.
4. **Inicialización del tiempo global** en `0`.

---

## 3. Ejecución de la Simulación

Un **controlador de tiempo** (`tiempoGlobal`) avanza paso a paso simulando el comportamiento del sistema.

Para cada instante de tiempo:

1. **Revisión de procesos listos para entrar**:

   * Si el `arrivaltime` del proceso ≤ `tiempoGlobal` y hay espacio libre suficiente en memoria → se intenta asignar.
   * Si no hay espacio o aún no llegó su turno → el simulador avanza el tiempo hasta que pueda ingresar.

2. **Asignación de memoria**:

   * Según la estrategia seleccionada, se busca un bloque libre y se crea/ajusta la partición para el proceso.
   * Se registra un evento: *"Partición creada y asignada al proceso X"*.
   * Se suma el **Tiempo de selección** al tiempo global.

3. **Carga del proceso**:

   * El proceso pasa a estado `enCarga` durante el **Tiempo de carga**.
   * Luego cambia a estado `enMemoria` (ejecutando).

4. **Ejecución**:

   * Cada unidad de tiempo, el atributo `duracion` del proceso se reduce.
   * Cuando llega a `0`, el proceso pasa a estado `finalizado`.
   * **Se calcula el Tiempo de Retorno**:

     $$
     T_{retorno} = T_{finalizacion} - T_{arribo}
     $$

5. **Liberación de memoria**:

   * El proceso entra en estado `enLiberacion` por el tiempo definido.
   * Al terminar, la partición se marca como libre y se unifican bloques adyacentes si corresponde.

6. **Continuación con otros procesos** hasta que la tanda se complete.

---

## 4. Salida de Resultados

El simulador genera:

* **Log de eventos**:

  * Momento en que cada proceso entra en memoria, termina su ejecución y libera la partición.
  * Estado de la tabla de particiones cada vez que cambia.

* **Indicadores de desempeño**:

  * **Para cada proceso**: Tiempo de Retorno.
  * **Para la tanda**:

    * Tiempo Total de Retorno.
    * Tiempo Medio de Retorno.
    * Índice de Fragmentación Externa.

* **Exportación de resultados** a un archivo `Simulacion_X.txt`, donde `X` es el número de simulación ejecutada.

---

## 5. Interfaz Visual

El sistema muestra en pantalla:

* **Ventana de texto** donde se detalla lo que ocurre en cada instante de tiempo.
* **Diagrama de Gantt interactivo**, con botones:

  * `<<`: Ir al tiempo inicial (0).
  * `<`: Retroceder un tiempo.
  * `>`: Avanzar un tiempo.
  * `>>`: Ir al tiempo final.

Esto permite observar visualmente el estado de cada proceso y de la memoria a lo largo de la simulación.

---
